<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CollagePro - Professional Collage Generator</title>
    
    <!-- Libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc;
        }
        
        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f5f9;
        }
        ::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        /* Loading Animation */
        .spinner {
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
<script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@^19.2.4",
    "react-dom/": "https://esm.sh/react-dom@^19.2.4/",
    "react/": "https://esm.sh/react@^19.2.4/",
    "lucide-react": "https://esm.sh/lucide-react@^0.563.0",
    "jszip": "https://esm.sh/jszip@^3.10.1"
  }
}
</script>
</head>
<body class="text-gray-900 pb-20">

    <!-- Header -->
    <header class="bg-white border-b border-gray-200 sticky top-0 z-30 shadow-sm">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 h-16 flex items-center justify-between">
            <div class="flex items-center gap-2">
                <div class="bg-indigo-600 p-2 rounded-lg shadow-sm">
                    <i data-lucide="layout" class="w-5 h-5 text-white"></i>
                </div>
                <h1 class="text-xl font-bold tracking-tight text-gray-900">CollagePro</h1>
            </div>
            
            <div class="flex items-center gap-3" id="header-actions" style="display: none;">
                <button onclick="app.clearResults()" class="flex items-center gap-2 px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 hover:bg-gray-50 rounded-lg transition-colors shadow-sm" title="Clears generated results but keeps uploaded images">
                    <i data-lucide="rotate-ccw" class="w-4 h-4"></i>
                    Reset Results
                </button>
            </div>
        </div>
    </header>

    <main class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8 space-y-8">
        
        <div class="grid grid-cols-1 lg:grid-cols-12 gap-8">
            
            <!-- Left Column: Uploads -->
            <div class="lg:col-span-4 space-y-6">
                <div class="bg-white p-6 rounded-2xl shadow-sm border border-gray-200">
                    <h2 class="text-lg font-bold mb-6 flex items-center gap-2 text-gray-900">
                        <span class="flex items-center justify-center w-7 h-7 rounded-full bg-indigo-600 text-white text-sm font-bold">1</span>
                        Upload Images
                    </h2>
                    
                    <div class="space-y-6">
                        <!-- Fixed Image Zone -->
                        <div class="bg-indigo-50/50 p-4 rounded-xl border border-indigo-100">
                            <div id="fixed-upload-zone"></div>
                        </div>
                        
                        <!-- Random Images Zone -->
                        <div class="bg-gray-50/50 p-4 rounded-xl border border-gray-100">
                            <div id="random-upload-zone"></div>
                        </div>
                    </div>
                    
                    <div id="upload-warning" class="mt-4 p-3 bg-amber-50 text-amber-800 text-sm rounded-lg border border-amber-200 flex items-start gap-2" style="display: none;">
                        <div class="mt-0.5">⚠️</div>
                        <div id="upload-warning-text">Please upload more images.</div>
                    </div>
                </div>
            </div>

            <!-- Right Column: Settings & Results -->
            <div class="lg:col-span-8 flex flex-col gap-6">
                
                <!-- Settings Panel -->
                <div class="bg-white p-6 rounded-2xl shadow-sm border border-gray-200">
                    <h2 class="text-lg font-bold mb-6 flex items-center gap-2 text-gray-900">
                        <span class="flex items-center justify-center w-7 h-7 rounded-full bg-indigo-600 text-white text-sm font-bold">2</span>
                        Configuration
                    </h2>
                    
                    <div class="space-y-6">
                        
                        <!-- Visual Aspect Ratio Selector -->
                        <div>
                            <label class="block text-sm font-semibold text-gray-700 mb-3 flex items-center gap-2">
                                <i data-lucide="settings" class="w-4 h-4 text-indigo-600"></i> Target Layout
                            </label>
                            <div class="grid grid-cols-2 sm:grid-cols-4 gap-3" id="aspect-ratio-container">
                                <!-- Generated by JS -->
                            </div>
                        </div>

                        <div class="h-px bg-gray-100 my-4"></div>

                        <div class="flex flex-col sm:flex-row gap-6">
                            <div class="flex-1">
                                <label class="block text-sm font-semibold text-gray-700 mb-2 flex items-center gap-2">
                                    <i data-lucide="zap" class="w-4 h-4 text-amber-500"></i> Output Resolution
                                </label>
                                <select id="quality-select" class="block w-full rounded-xl border-gray-200 bg-gray-50 border py-2.5 px-4 text-gray-900 focus:ring-2 focus:ring-indigo-600 focus:border-indigo-600 sm:text-sm transition-shadow cursor-pointer">
                                    <option value="2K" selected>High Quality (2K) - Fast</option>
                                    <option value="4K">Ultra Quality (4K) - Print Ready</option>
                                </select>
                            </div>

                            <div class="flex items-end flex-1">
                                <button id="generate-btn" onclick="app.generate()" class="w-full flex items-center justify-center gap-2 px-6 py-2.5 rounded-xl font-bold text-white shadow-md transition-all bg-gray-300 cursor-not-allowed shadow-none" disabled>
                                    Generate Collages <i data-lucide="zap" class="w-4 h-4 fill-white"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Progress Section -->
                <div id="progress-container" class="w-full py-20 flex flex-col items-center justify-center text-center bg-white rounded-2xl border border-gray-100 shadow-sm" style="display: none;">
                    <div class="w-64 h-2 bg-gray-100 rounded-full overflow-hidden mb-6">
                        <div id="progress-bar" class="h-full bg-indigo-600 transition-all duration-300 ease-out" style="width: 0%"></div>
                    </div>
                    <div class="flex items-center gap-3 text-indigo-600 mb-2">
                        <i data-lucide="loader-2" class="w-5 h-5 spinner"></i>
                        <h3 class="text-lg font-semibold">Creating Variations...</h3>
                    </div>
                    <p id="progress-text" class="text-gray-500 text-sm">Initializing...</p>
                </div>

                <!-- Results Grid -->
                <div id="results-container" class="w-full fade-in" style="display: none;">
                    <div class="flex items-center justify-between mb-6">
                        <h2 class="text-2xl font-bold text-gray-900">Generated Collages</h2>
                        <span id="results-count" class="text-sm font-medium text-indigo-700 bg-indigo-50 border border-indigo-100 px-3 py-1 rounded-full">
                            0 Variations
                        </span>
                    </div>
                    
                    <div id="collage-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
                        <!-- Generated items -->
                    </div>

                    <div class="flex justify-center pt-8">
                        <button onclick="app.downloadAll()" class="flex items-center gap-2 px-8 py-4 bg-gray-900 text-white rounded-full font-bold shadow-lg hover:bg-gray-800 hover:scale-105 transition-all">
                            <i data-lucide="download" class="w-5 h-5"></i>
                            Download All Collages (ZIP)
                        </button>
                    </div>
                </div>

            </div>
        </div>
    </main>

    <!-- Templates & Logic -->
    <script>
        // Constants
        const ASPECT_RATIOS = {
            '1:1': { width: 1, height: 1, label: 'Square (1:1)' },
            '9:16': { width: 9, height: 16, label: 'Portrait (9:16)' },
            '16:9': { width: 16, height: 9, label: 'Landscape (16:9)' },
            '3:4': { width: 3, height: 4, label: 'Portrait (3:4)' },
            '4:3': { width: 4, height: 3, label: 'Landscape (4:3)' },
            '1200:628': { width: 1200, height: 628, label: 'Social Post (1200x628)' },
            '900:1600': { width: 900, height: 1600, label: 'Story (900x1600)' },
        };
        const RESOLUTIONS = { '2K': 2048, '4K': 3840 };
        const MAX_ZONE_2_IMAGES = 20;
        const MIN_ZONE_2_IMAGES = 2;
        const TOTAL_COLLAGES_TO_GENERATE = 20;

        // State
        const state = {
            baseImage: null,
            randomImages: [],
            aspectRatio: '1:1',
            quality: '2K',
            generatedCollages: [],
            isGenerating: false,
            downloadingId: null
        };

        // --- Core Engine Logic ---
        
        const loadImage = (url) => {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = url;
            });
        };

        const drawImageCover = (ctx, img, x, y, w, h) => {
            const imgRatio = img.width / img.height;
            const rectRatio = w / h;
            let renderW, renderH, renderX, renderY;

            if (imgRatio > rectRatio) {
                renderH = h;
                renderW = h * imgRatio;
                renderY = y;
                renderX = x - (renderW - w) / 2;
            } else {
                renderW = w;
                renderH = w / imgRatio;
                renderX = x;
                renderY = y - (renderH - h) / 2;
            }

            ctx.save();
            ctx.beginPath();
            ctx.rect(x, y, w, h);
            ctx.clip();
            ctx.drawImage(img, renderX, renderY, renderW, renderH);
            ctx.restore();
        };

        const generateBSPLayout = (width, height, count) => {
            let rects = [{ x: 0, y: 0, w: width, h: height }];

            while (rects.length < count) {
                rects.sort((a, b) => b.w * b.h - a.w * a.h);
                const largest = rects.shift();

                const splitHorizontal = largest.w > largest.h; 
                const ratio = largest.w / largest.h;
                const isSquareish = ratio > 0.8 && ratio < 1.2;
                const splitDir = isSquareish ? (Math.random() > 0.5) : splitHorizontal;
                const splitPercent = 0.3 + Math.random() * 0.4;

                if (splitDir) {
                    const w1 = Math.floor(largest.w * splitPercent);
                    const w2 = largest.w - w1;
                    rects.push(
                        { x: largest.x, y: largest.y, w: w1, h: largest.h },
                        { x: largest.x + w1, y: largest.y, w: w2, h: largest.h }
                    );
                } else {
                    const h1 = Math.floor(largest.h * splitPercent);
                    const h2 = largest.h - h1;
                    rects.push(
                        { x: largest.x, y: largest.y, w: largest.w, h: h1 },
                        { x: largest.x, y: largest.y + h1, w: largest.w, h: h2 }
                    );
                }
            }
            return rects;
        };

        const generateSingleCollage = async (baseImage, randomImages, aspectRatioKey, qualityKey) => {
            const longSide = RESOLUTIONS[qualityKey];
            const ar = ASPECT_RATIOS[aspectRatioKey];
            let width, height;

            if (ar.width >= ar.height) {
                width = longSide;
                height = Math.round(longSide * (ar.height / ar.width));
            } else {
                height = longSide;
                width = Math.round(longSide * (ar.width / ar.height));
            }

            const minImages = 2;
            const maxImages = Math.min(6, randomImages.length + 1);
            const totalCount = Math.floor(Math.random() * (maxImages - minImages + 1)) + minImages;

            const shuffled = [...randomImages].sort(() => 0.5 - Math.random());
            const selectedRandoms = shuffled.slice(0, totalCount - 1);
            const allSelected = [baseImage, ...selectedRandoms];

            const layout = generateBSPLayout(width, height, totalCount);
            
            // Logic to find largest slot for base image
            const sortedLayoutIndices = layout.map((_, i) => i).sort((a, b) => {
                return (layout[b].w * layout[b].h) - (layout[a].w * layout[a].h);
            });
            const baseImageSlotIndex = sortedLayoutIndices[0];

            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, width, height);

            const assignments = new Array(totalCount);
            assignments[baseImageSlotIndex] = baseImage;
            
            let randomIdx = 0;
            for (let i = 0; i < totalCount; i++) {
                if (i !== baseImageSlotIndex) {
                    assignments[i] = selectedRandoms[randomIdx];
                    randomIdx++;
                }
            }

            const processImage = async (imgData, rect) => {
                const img = await loadImage(imgData.url);
                drawImageCover(ctx, img, rect.x, rect.y, rect.w, rect.h);
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = Math.max(2, width * 0.005);
                ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
            };

            await Promise.all(layout.map((rect, i) => processImage(assignments[i], rect)));

            return new Promise((resolve, reject) => {
                canvas.toBlob((blob) => {
                    if (blob) {
                        const url = URL.createObjectURL(blob);
                        resolve({ blob, url, usedImages: allSelected });
                    } else {
                        reject(new Error('Canvas failed'));
                    }
                }, qualityKey === '4K' ? 'image/jpeg' : 'image/jpeg', 0.92);
            });
        };

        // --- Application Logic ---

        const app = {
            init: () => {
                app.renderUploadZones();
                app.renderAspectRatioSelector();
                
                // Bind Global Events
                document.getElementById('quality-select').addEventListener('change', (e) => {
                    state.quality = e.target.value;
                });

                // Initialize icons
                lucide.createIcons();
            },

            // UI Renderers
            renderUploadZones: () => {
                // Render Fixed Zone
                const fixedZone = document.getElementById('fixed-upload-zone');
                fixedZone.innerHTML = app.buildZoneHTML('Fixed Image (Star)', 'Appears prominently in every collage', state.baseImage ? [state.baseImage] : [], 1, true, false);
                
                // Render Random Zone
                const randomZone = document.getElementById('random-upload-zone');
                randomZone.innerHTML = app.buildZoneHTML('Gallery Images', `Mix & match pool (${MIN_ZONE_2_IMAGES}-${MAX_ZONE_2_IMAGES} photos)`, state.randomImages, MAX_ZONE_2_IMAGES, true, true);

                // Validation UI
                const warningEl = document.getElementById('upload-warning');
                const warningText = document.getElementById('upload-warning-text');
                const btn = document.getElementById('generate-btn');

                const missing = MIN_ZONE_2_IMAGES - state.randomImages.length;
                if (state.randomImages.length > 0 && missing > 0) {
                    warningEl.style.display = 'flex';
                    warningText.innerText = `Please upload at least ${missing} more gallery image(s).`;
                } else {
                    warningEl.style.display = 'none';
                }

                // Button State
                const canGenerate = state.baseImage && state.randomImages.length >= MIN_ZONE_2_IMAGES;
                btn.disabled = !canGenerate;
                if (canGenerate) {
                    btn.classList.remove('bg-gray-300', 'cursor-not-allowed', 'shadow-none');
                    btn.classList.add('bg-indigo-600', 'hover:bg-indigo-700', 'hover:scale-[1.02]', 'shadow-indigo-200');
                } else {
                    btn.classList.add('bg-gray-300', 'cursor-not-allowed', 'shadow-none');
                    btn.classList.remove('bg-indigo-600', 'hover:bg-indigo-700', 'hover:scale-[1.02]', 'shadow-indigo-200');
                }
                
                // Refresh Icons
                lucide.createIcons();
            },

            buildZoneHTML: (title, description, files, max, required, multiple) => {
                const isFull = files.length >= max;
                const uploadId = multiple ? 'random-upload' : 'fixed-upload';
                
                let content = '';
                
                if (files.length === 0) {
                    content = `
                        <div class="flex flex-col items-center justify-center text-center cursor-pointer h-32" onclick="document.getElementById('${uploadId}').click()">
                            <div class="bg-indigo-100 p-3 rounded-full mb-3">
                                <i data-lucide="upload" class="w-6 h-6 text-indigo-600"></i>
                            </div>
                            <p class="text-sm font-medium text-gray-900">Click to upload</p>
                            <p class="text-xs text-gray-500 mt-1">${description}</p>
                        </div>
                    `;
                } else {
                    const grid = files.map(f => `
                        <div class="group relative aspect-square rounded-lg overflow-hidden border border-gray-200 bg-white">
                            <img src="${f.url}" class="w-full h-full object-cover">
                            <div class="absolute inset-0 bg-black/40 opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center">
                                <button onclick="app.removeImage('${f.id}', ${multiple})" class="p-1.5 bg-red-500 text-white rounded-full hover:bg-red-600 transition-colors">
                                    <i data-lucide="x" class="w-4 h-4"></i>
                                </button>
                            </div>
                        </div>
                    `).join('');

                    const addBtn = (!isFull) ? `
                        <div class="aspect-square flex flex-col items-center justify-center border-2 border-dashed border-gray-300 rounded-lg cursor-pointer hover:bg-gray-50 text-gray-400 hover:text-gray-600 transition-colors" onclick="document.getElementById('${uploadId}').click()">
                            <i data-lucide="upload" class="w-5 h-5 mb-1"></i>
                            <span class="text-xs">Add</span>
                        </div>
                    ` : '';

                    content = `<div class="grid grid-cols-2 sm:grid-cols-3 gap-3">${grid}${addBtn}</div>`;
                }

                return `
                    <div class="w-full">
                        <div class="flex justify-between items-center mb-2">
                            <label class="text-sm font-semibold text-gray-700 flex items-center gap-1">
                                ${title} ${required ? '<span class="text-red-500">*</span>' : ''}
                            </label>
                            <span class="text-xs text-gray-500">${files.length} / ${max}</span>
                        </div>
                        <div class="relative border-2 border-dashed rounded-xl p-6 transition-all duration-200 ${isFull && !multiple ? 'border-gray-200 bg-gray-50' : 'border-indigo-200 hover:border-indigo-400 bg-indigo-50/30'}">
                            ${content}
                            <input type="file" id="${uploadId}" class="hidden" ${multiple ? 'multiple' : ''} accept="image/*" onchange="app.handleUpload(this, ${multiple})">
                        </div>
                    </div>
                `;
            },

            renderAspectRatioSelector: () => {
                const container = document.getElementById('aspect-ratio-container');
                container.innerHTML = Object.entries(ASPECT_RATIOS).map(([key, value]) => {
                    const isSelected = state.aspectRatio === key;
                    let icon = 'rectangle-horizontal';
                    if (key === '1:1') icon = 'square';
                    if (['9:16', '3:4', '900:1600'].includes(key)) icon = 'rectangle-vertical';

                    return `
                        <button onclick="app.setRatio('${key}')" class="flex flex-col items-center justify-center p-3 rounded-xl border-2 transition-all duration-200 ${isSelected ? 'border-indigo-600 bg-indigo-50 text-indigo-700 ring-2 ring-indigo-100' : 'border-gray-100 bg-white text-gray-600 hover:border-gray-300 hover:bg-gray-50'}">
                            <div class="mb-2 opacity-80 ${isSelected ? 'text-indigo-600' : 'text-gray-400'}">
                                <i data-lucide="${icon}" class="w-5 h-5"></i>
                            </div>
                            <span class="text-xs font-semibold">${key.replace(':', ' : ')}</span>
                            <span class="text-[10px] opacity-70 mt-0.5 text-center leading-tight">${value.label.split('(')[0]}</span>
                        </button>
                    `;
                }).join('');
                lucide.createIcons();
            },

            renderCollageGrid: () => {
                const container = document.getElementById('results-container');
                const grid = document.getElementById('collage-grid');
                const count = document.getElementById('results-count');
                const headerActions = document.getElementById('header-actions');
                
                if (state.generatedCollages.length === 0) {
                    container.style.display = 'none';
                    headerActions.style.display = 'none';
                    return;
                }

                container.style.display = 'block';
                headerActions.style.display = 'flex';
                count.innerText = `${state.generatedCollages.length} Variations`;

                grid.innerHTML = state.generatedCollages.map(collage => `
                    <div class="group bg-white rounded-xl shadow-sm border border-gray-200 overflow-hidden transition-all hover:shadow-lg hover:border-indigo-200 flex flex-col">
                        <div class="aspect-[4/3] w-full relative bg-gray-100 overflow-hidden cursor-pointer" onclick="window.open('${collage.url}', '_blank')">
                            <img src="${collage.url}" class="w-full h-full object-contain bg-gray-50 p-2">
                            <div class="absolute inset-0 bg-black/0 group-hover:bg-black/10 transition-colors flex items-center justify-center">
                                <div class="bg-white/90 backdrop-blur-sm text-gray-700 px-3 py-1.5 rounded-full text-xs font-semibold shadow-sm opacity-0 group-hover:opacity-100 transition-opacity transform translate-y-2 group-hover:translate-y-0">
                                    Click to Zoom
                                </div>
                            </div>
                        </div>
                        <div class="p-4 bg-white flex flex-col gap-3 border-t border-gray-100">
                            <div class="flex justify-between items-start">
                                <div>
                                    <h4 class="text-sm font-semibold text-gray-900 truncate w-40" title="${collage.name}">${collage.name}</h4>
                                    <p class="text-xs text-gray-500 mt-0.5">${collage.usedImages.length} images used</p>
                                </div>
                            </div>
                            <div class="grid grid-cols-2 gap-2 mt-1">
                                <button onclick="app.downloadSingle('${collage.url}', '${collage.name}')" class="flex items-center justify-center gap-1.5 px-3 py-2 bg-white border border-gray-200 text-gray-700 rounded-lg hover:bg-gray-50 hover:border-gray-300 transition-colors text-xs font-medium">
                                    <i data-lucide="image" class="w-3.5 h-3.5"></i> Result
                                </button>
                                <button onclick="app.downloadPack('${collage.id}')" class="flex items-center justify-center gap-1.5 px-3 py-2 bg-indigo-50 border border-indigo-100 text-indigo-700 rounded-lg hover:bg-indigo-100 transition-colors text-xs font-medium">
                                    ${state.downloadingId === collage.id ? '<i data-lucide="loader-2" class="w-3.5 h-3.5 spinner"></i>' : '<i data-lucide="package" class="w-3.5 h-3.5"></i>'} 
                                    Source Pack
                                </button>
                            </div>
                        </div>
                    </div>
                `).join('');
                
                lucide.createIcons();
            },

            // Logic Actions
            handleUpload: (input, isMultiple) => {
                const files = Array.from(input.files);
                if (files.length === 0) return;

                if (isMultiple) {
                    const remaining = MAX_ZONE_2_IMAGES - state.randomImages.length;
                    const toAdd = files.slice(0, remaining).map(f => ({
                        id: Math.random().toString(36).substr(2, 9),
                        url: URL.createObjectURL(f),
                        file: f
                    }));
                    state.randomImages = [...state.randomImages, ...toAdd];
                } else {
                    if (state.baseImage) URL.revokeObjectURL(state.baseImage.url);
                    state.baseImage = {
                        id: Math.random().toString(36).substr(2, 9),
                        url: URL.createObjectURL(files[0]),
                        file: files[0]
                    };
                }
                input.value = '';
                app.renderUploadZones();
            },

            removeImage: (id, isMultiple) => {
                if (isMultiple) {
                    state.randomImages = state.randomImages.filter(img => img.id !== id);
                } else {
                    state.baseImage = null;
                }
                app.renderUploadZones();
            },

            setRatio: (ratio) => {
                state.aspectRatio = ratio;
                app.renderAspectRatioSelector();
            },

            clearResults: () => {
                state.generatedCollages.forEach(c => URL.revokeObjectURL(c.url));
                state.generatedCollages = [];
                app.renderCollageGrid();
            },

            generate: async () => {
                if (!state.baseImage || state.randomImages.length < MIN_ZONE_2_IMAGES) return;
                
                state.isGenerating = true;
                app.clearResults();
                
                // Show Progress
                document.getElementById('progress-container').style.display = 'flex';
                document.getElementById('results-container').style.display = 'none';
                const progressBar = document.getElementById('progress-bar');
                const progressText = document.getElementById('progress-text');
                
                const results = [];

                try {
                    for (let i = 0; i < TOTAL_COLLAGES_TO_GENERATE; i++) {
                        // Update UI
                        const pct = ((i + 1) / TOTAL_COLLAGES_TO_GENERATE) * 100;
                        progressBar.style.width = `${pct}%`;
                        progressText.innerText = `Generating collage ${i + 1} of ${TOTAL_COLLAGES_TO_GENERATE}`;
                        
                        await new Promise(resolve => setTimeout(resolve, 50)); // Yield to UI

                        const result = await generateSingleCollage(
                            state.baseImage,
                            state.randomImages,
                            state.aspectRatio,
                            state.quality,
                            i
                        );

                        results.push({
                            id: Math.random().toString(36),
                            url: result.url,
                            blob: result.blob,
                            name: `Collage-${i + 1}.jpg`,
                            usedImages: result.usedImages
                        });
                    }
                    state.generatedCollages = results;
                } catch (e) {
                    console.error(e);
                    alert("Generation failed. Check console.");
                } finally {
                    state.isGenerating = false;
                    document.getElementById('progress-container').style.display = 'none';
                    app.renderCollageGrid();
                }
            },

            downloadSingle: (url, name) => {
                const a = document.createElement('a');
                a.href = url;
                a.download = name;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            },

            downloadPack: async (id) => {
                const collage = state.generatedCollages.find(c => c.id === id);
                if (!collage) return;

                state.downloadingId = id;
                app.renderCollageGrid(); // Refresh UI for spinner

                try {
                    const zip = new JSZip();
                    zip.file(`RESULT_${collage.name}`, collage.blob);
                    
                    const folder = zip.folder("source_images");
                    collage.usedImages.forEach((img, idx) => {
                         folder.file(`source_${idx + 1}_${img.file.name}`, img.file);
                    });

                    const content = await zip.generateAsync({ type: 'blob' });
                    const url = URL.createObjectURL(content);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `Pack_${collage.name.replace('.jpg', '')}.zip`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                } catch (e) {
                    alert("Zip failed");
                } finally {
                    state.downloadingId = null;
                    app.renderCollageGrid();
                }
            },

            downloadAll: async () => {
                if (state.generatedCollages.length === 0) return;
                
                try {
                    const zip = new JSZip();
                    state.generatedCollages.forEach(c => {
                        zip.file(c.name, c.blob);
                    });
                    const content = await zip.generateAsync({ type: 'blob' });
                    const url = URL.createObjectURL(content);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'All_Collages.zip';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                } catch (e) {
                    alert("Download all failed");
                }
            }
        };

        // Start
        window.addEventListener('DOMContentLoaded', app.init);
    </script>
</body>
</html>